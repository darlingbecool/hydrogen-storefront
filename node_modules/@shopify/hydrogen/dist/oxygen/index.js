// src/createRequestHandler.ts
import {
  createRequestHandler as createReactRouterRequestHandler
} from "react-router";

// src/context-keys.ts
import { createContext } from "react-router";
var storefrontContext = createContext();
var cartContext = createContext();
var customerAccountContext = createContext();
var envContext = createContext();
var sessionContext = createContext();
var waitUntilContext = createContext();

// src/constants.ts
var SHOPIFY_CLIENT_IP_SIG_HEADER = "X-Shopify-Client-IP-Sig";
var HYDROGEN_SFAPI_PROXY_KEY = "_sfapi_proxy";

// src/utils/server-timing.ts
function buildServerTimingHeader(values) {
  return Object.entries(values).map(([key, value]) => value ? `${key};desc=${value}` : void 0).filter(Boolean).join(", ");
}
function appendServerTimingHeader(response, values) {
  const header = typeof values === "string" ? values : buildServerTimingHeader(values);
  if (header) {
    response.headers.append("Server-Timing", header);
  }
}

// src/utils/warning.ts
var warnings = /* @__PURE__ */ new Set();
var warnOnce = (string) => {
  if (!warnings.has(string)) {
    console.warn(string);
    warnings.add(string);
  }
};

// src/createRequestHandler.ts
function createRequestHandler({
  build,
  mode,
  poweredByHeader = true,
  getLoadContext,
  collectTrackingInformation = true,
  proxyStandardRoutes = true
}) {
  const handleRequest = createReactRouterRequestHandler(build, mode);
  const appendPoweredByHeader = poweredByHeader ? (response) => response.headers.append("powered-by", "Shopify, Hydrogen") : void 0;
  return async (request) => {
    const method = request.method;
    if ((method === "GET" || method === "HEAD") && request.body) {
      return new Response(`${method} requests cannot have a body`, {
        status: 400
      });
    }
    const url = new URL(request.url);
    if (url.pathname.includes("//")) {
      return new Response(null, {
        status: 301,
        headers: {
          location: url.pathname.replace(/\/+/g, "/")
        }
      });
    }
    const context = await getLoadContext?.(request);
    const storefront = context?.storefront || context?.get?.(storefrontContext);
    if (proxyStandardRoutes) {
      if (!storefront) {
        warnOnce(
          "[h2:createRequestHandler] Storefront instance is required to proxy standard routes."
        );
      }
      if (storefront?.isStorefrontApiUrl(request)) {
        const response2 = await storefront.forward(request);
        appendPoweredByHeader?.(response2);
        return response2;
      }
    }
    const response = await handleRequest(request, context);
    if (storefront && proxyStandardRoutes) {
      if (collectTrackingInformation) {
        storefront.setCollectedSubrequestHeaders(response);
      }
      const fetchDest = request.headers.get("sec-fetch-dest");
      if (fetchDest && fetchDest === "document" || request.headers.get("accept")?.includes("text/html")) {
        appendServerTimingHeader(response, { [HYDROGEN_SFAPI_PROXY_KEY]: "1" });
      }
    }
    appendPoweredByHeader?.(response);
    return response;
  };
}

// src/utils/request.ts
function getHeader(request, key) {
  return getHeaderValue(request.headers, key);
}
function getHeaderValue(headers, key) {
  const value = headers?.get?.(key) ?? headers?.[key];
  return typeof value === "string" ? value : null;
}
function getStorefrontHeaders(request) {
  return {
    requestGroupId: getHeader(request, "request-id"),
    buyerIp: getHeader(request, "oxygen-buyer-ip"),
    buyerIpSig: getHeader(request, SHOPIFY_CLIENT_IP_SIG_HEADER),
    cookie: getHeader(request, "cookie"),
    // sec-purpose is added by browsers automatically when using link/prefetch or Speculation Rules
    purpose: getHeader(request, "sec-purpose") || getHeader(request, "purpose")
  };
}
export {
  createRequestHandler,
  getStorefrontHeaders
};
